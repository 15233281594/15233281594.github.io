[{"title":"Three.js","url":"/posts/19462.html","content":"\n# Three.js 性能优化\n\n<!-- more -->\n\n#### 1.渲染，抗锯齿优化\n\n```javascript\n const renderer = new THREE.WebGLRenderer({\n    canvas,\n    antialias: true,  //是否启用抗锯齿\n  });\n\n需求场景：根据用户设备判断cpu性能，gpu性能，如果性能比较差，就把抗锯齿关掉，如果性能好就把抗锯齿打开，就和游戏中的高画质，低画质一样，属于画质切换。\n\n抗锯齿其实底层就是一套数学算法，开启它后会增加性能开销。\n```\n\n```javascript\n在 Three.js 中，顶点着色器中的变量可以使用 uniform、attribute 和 varying。这些不同类型的变量用于不同的目的：\n\nUniform:\n用于从 JavaScript 代码传递全局变量到着色器，这些变量在一个绘制调用期间对所有顶点（顶点着色器）或片元（片元着色器）都保持不变。\n在顶点着色器中使用 uniform 变量时，通常用于传递变换矩阵、时间、光源参数等。\n\nAttribute:\n用于从 JavaScript 代码传递每个顶点独特的数据到顶点着色器，例如顶点位置、法向量、纹理坐标等。\n在片元着色器中不能直接使用 attribute，只能在顶点着色器中使用。\n\nVarying:\n用于在顶点着色器和片元着色器之间传递数据。顶点着色器计算出 varying 变量的值，并将其插值后传递给片元着色器。\n在顶点着色器中定义 varying 变量，并在片元着色器中使用。\n```\n\n#### 2.性能指标检测\n\n- 1.用户的设备性能标准 2.监测帧率 --stats.js\n\n```javascript\nfunction estimatePerformance() {\n  // 获取 CPU 核心数\n  const cores = navigator.hardwareConcurrency || 1;\n\n  // 测量一个操作的执行时间\n  const start = performance.now();\n  for (let i = 0; i < 1e7; i++) {} // 简单的计算任务\n  const end = performance.now();\n  const duration = end - start;\n\n  // 根据核心数和执行时间估计性能\n  if (cores >= 8 && duration < 50) {\n    console.log(\"高性能设备\");\n  } else if (cores >= 4 && duration < 100) {\n    console.log(\"中等性能设备\");\n  } else {\n    console.log(\"低性能设备\");\n  }\n}\n\nestimatePerformance();\n```\n\n#### 3.画面 resize 优化，开启节流\n\n```javascript\nwindow.addEventListener(\"resize\", () => {\n  console.log(\"resize\");\n  // 更新宽高比\n  camera.aspect = window.innerWidth / window.innerHeight;\n  // 更新相机的投影矩阵\n  camera.updateProjectionMatrix();\n\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  // 设置像素比\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n});\n```\n\n#### 4.创建点云可以关闭深度测试\n\n- 损失渲染精度\n\n2.  获得好的性能\n\n```javascript\nthis.material = new THREE.PointsMaterial({\n  size: 50,\n  map: new THREE.TextureLoader().load(smoke_png),\n  transparent: true,\n  depthWrite: false,\n});\n```\n\n#### 5.尽量使用 clone\n\n- threejs 一切皆对象。适合： 相似度比较高的物体。\n- 在 Three.js 中，clone 方法用于创建一个对象的深拷贝。这个方法可以应用于几乎所有的 Three.js 对象，包括几何体、材质、网格、场景等。通过 clone 方法，你可以复制一个对象及其所有属性，而不会影响原始对象。\n\n```javascript\n在 Three.js 中使用 clone 方法可以对性能产生积极影响，主要原因如下：\n1. 减少计算开销：克隆对象时，Three.js 会复制现有对象的所有属性和状态，而不需要重新计算几何体、材质或其他复杂属性。这减少了 CPU 的计算开销。\n2. 共享资源：克隆的对象可以共享一些资源（如纹理、材质等），而不需要为每个对象创建新的资源。这减少了内存使用和加载时间。\n3. 简化代码：使用 clone 方法可以简化代码，使得创建多个相似对象变得更加容易和高效。这有助于减少代码的复杂性和潜在的错误。\n```\n\n#### 6.不需要的对象要销毁\n\n- 不销毁的坏处？\n\n1. 占用内存，可能会有内存泄露\n2. 有额外的渲染开销\n\n- 在 Three.js 中，`dispose` 方法用于释放对象占用的内存资源。对于几何体、材质、纹理等对象，调用 `dispose` 方法可以确保这些资源被正确地释放，从而避免内存泄漏。\n\n```javascript\nimport * as THREE from \"three\";\nimport { TextGeometry } from \"three/examples/jsm/geometries/TextGeometry.js\";\n\nclass TextManager {\n  constructor(font) {\n    this.font = font;\n    this.texts = [];\n    this.init();\n  }\n\n  init() {\n    [\n      { text: \"Hello\", color: \"#ffffff\" },\n      { text: \"Three.js\", color: \"#ffffff\" },\n    ].forEach((item) => {\n      this.createText(item);\n    });\n  }\n\n  createText(data) {\n    const geometry = new TextGeometry(data.text, {\n      font: this.font,\n      size: 20,\n      height: 2,\n    });\n\n    const material = new THREE.ShaderMaterial({\n      vertexShader: `\n        void main() {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        void main() {\n          gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        }\n      `,\n    });\n\n    const mesh = new THREE.Mesh(geometry, material);\n    this.texts.push(mesh);\n  }\n\n  dispose() {\n    this.texts.forEach((mesh) => {\n      mesh.geometry.dispose();\n      mesh.material.dispose();\n    });\n    this.texts = [];\n  }\n}\n\n// 示例使用\nconst fontLoader = new THREE.FontLoader();\nfontLoader.load(\"path/to/font.json\", function (font) {\n  const textManager = new TextManager(font);\n\n  // 在需要释放资源时调用 dispose 方法\n  textManager.dispose();\n});\n```\n\n#### 7.尽量使用 BufferGeometry\n\n- 使用 `BufferGeometry` 对性能更好。`BufferGeometry` 是 Three.js 中的一种几何体类型，它比传统的 `Geometry` 更高效，特别是在处理大量顶点数据时。`BufferGeometry` 直接使用 WebGL 的缓冲区来存储顶点数据，从而减少了内存占用和 CPU 开销。\n  1. **直接使用 WebGL 缓冲区**：`BufferGeometry` 直接使用 WebGL 的缓冲区来存储顶点数据。这意味着数据可以直接传递给 GPU（利用显存），而不需要在 CPU 和 GPU 之间进行额外的转换和处理。\n  2. **内存布局更紧凑**：`BufferGeometry` 使用类型化数组（如 `Float32Array`）来存储顶点数据，这种内存布局更紧凑，减少了内存占用和缓存未命中。\n  3. **减少 CPU 开销**：由于 `BufferGeometry` 的数据结构更简单，Three.js 在处理几何体时需要的 CPU 计算量更少。这使得渲染过程更加高效，特别是在处理大量顶点数据时。\n  4. **更灵活的顶点属性**：`BufferGeometry` 允许你定义自定义的顶点属性（如颜色、法线、UV 坐标等），并且可以更灵活地控制这些属性的更新和使用。\n\n```javascript\nimport * as THREE from \"three\";\nimport { FontLoader } from \"three/examples/jsm/loaders/FontLoader.js\";\nimport { TextGeometry } from \"three/examples/jsm/geometries/TextGeometry.js\";\n\nclass TextManager {\n  constructor(font) {\n    this.font = font;\n    this.texts = [];\n    this.init();\n  }\n\n  init() {\n    [\n      { text: \"Hello\", color: \"#ffffff\" },\n      { text: \"Three.js\", color: \"#ffffff\" },\n    ].forEach((item) => {\n      this.createText(item);\n    });\n  }\n\n  createText(data) {\n    const geometry = new TextGeometry(data.text, {\n      font: this.font,\n      size: 20,\n      height: 2,\n    });\n\n    // 将 TextGeometry 转换为 BufferGeometry\n    const bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);\n\n    const material = new THREE.ShaderMaterial({\n      vertexShader: `\n        void main() {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        void main() {\n          gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        }\n      `,\n    });\n\n    const mesh = new THREE.Mesh(bufferGeometry, material);\n    this.texts.push(mesh);\n  }\n\n  dispose() {\n    this.texts.forEach((mesh) => {\n      mesh.geometry.dispose();\n      mesh.material.dispose();\n    });\n    this.texts = [];\n  }\n}\n\n// 示例使用\nconst fontLoader = new FontLoader();\nfontLoader.load(\"path/to/font.json\", function (font) {\n  const textManager = new TextManager(font);\n\n  // 在需要释放资源时调用 dispose 方法\n  textManager.dispose();\n});\n```\n\n#### 8.图片纹理优化\n\n- 在 Three.js 中，可以通过使用压缩纹理来减少内存占用和提高渲染性能。常见的压缩纹理格式包括 `DDS`、`KTX` 和 `PVR`。这些格式可以显著减少纹理的内存占用，并且在 GPU 上的解压缩速度非常快。\n- 纹理压缩格式有多种，每种格式都有其独特的优点和适用场景。以下是一些常见的纹理压缩格式及其区别：\n\n```html\n1. DDS (DirectDraw Surface) - 优点： - 支持多种压缩格式（如 DXT1、DXT5）。 -\n广泛支持，特别是在 DirectX 环境中。 - 支持 mipmap 和立方体贴图。 - 缺点： -\n文件较大。 - 不支持所有平台，特别是在 WebGL 环境中。 2. KTX (Khronos Texture)\n---这种最常用，且普遍 - 优点： - 支持多种压缩格式（如 ETC1、ETC2、ASTC）。 -\n适用于 OpenGL 和 WebGL。 - 支持 mipmap 和立方体贴图。 - 缺点： -\n需要额外的工具来生成 KTX 文件。 3. PVR (PowerVR Texture) - 优点： -\n专为移动设备设计，特别是 PowerVR GPU。 - 高压缩率，适合存储空间有限的设备。 -\n支持 mipmap 和立方体贴图。 - 缺点： - 仅在支持 PowerVR GPU 的设备上表现最佳。 4.\nBasis Universal - 优点： - 支持多种平台和 GPU。 - 高压缩率，适合网络传输。 -\n可以在运行时解码为多种 GPU 纹理格式。 - 缺点： - 需要额外的库来解码。\n```\n\n#### 9.在需要的时候进行 render\n\n- threejs，项目通常在使用 render 的函数中，是一直在执行的，就是说 gpu 是一直在占用的。导致他一直在占用电脑性能\n\n```javascript\n//每一帧render\nconst start = () => {\n  //每一帧的间隔时间,以秒为单位\n  // console.log(clock.getDelta());\n  const delta = clock.getDelta();\n\n  city.start(delta);\n\n  renderer.render(scene, camera);\n  requestAnimationFrame(start);\n};\nstart();\n```\n\n- 怎么解决？\n\n在需要的时候，设置一个开关\n\n- 使用场景\n\n1. 挂机时间远远大于需要动态渲染的时间\n2. 挂机的时候，状态可以是静止\n3. 本来是一直运动的，但是长时间不管，静止也 ok\n\n```javascript\nlet renderEnabled = false;\nlet timeOut: number;\n\nconst animate = () => {\n  requestAnimationFrame(animate);\n  // 设置一个变量 减少没用的执行\n  if (renderEnabled) {\n    // 这里是你自己业务上需要的code\n    controls.update(clock.getDelta());\n    renderer.render(scene, camera);\n  }\n  stats.update();\n};\n\n// 需要渲染的时候调用一下即可\nconst timeRender = (time: number = 3000) => {\n  renderEnabled = true;\n  clearTimeout(timeOut);\n  timeOut = setTimeout(() => {\n    renderEnabled = false;\n  }, time);\n};\n\n// 启动动画循环\nanimate();\n```\n\n#### 10.gltf 模型压缩\n\n- `gltf-pipeline` 是一个用于处理和优化 glTF 文件的工具库。它可以用于压缩、转换和优化 glTF 3D 模型，以提高加载性能和减少文件大小。\n- npm install -g gltf-pipeline\n\n```Javascript\n//在node端运行\n\nconst fs = require('fs');\nconst path = require('path');\nconst gltfPipeline = require('gltf-pipeline');\n\nconst inputFilePath = 'path/to/your/input.gltf';\nconst outputFilePath = 'path/to/your/output.gltf';\n\nconst gltf = fs.readFileSync(inputFilePath);\n\ngltfPipeline.processGltf(gltf, { dracoOptions: { compressionLevel: 10 } })\n  .then((results) => {\n    fs.writeFileSync(outputFilePath, Buffer.from(results.gltf));\n    console.log('Optimization complete.');\n  })\n  .catch((error) => {\n    console.error('Error during optimization:', error);\n  });\n```\n\n- gltf-pipeline 的底层是 Draco（zhua kou）\n- Draco 是 Google 开发的一种开源库，用于压缩和解压缩 3D 图形数据。它可以显著减少 3D 模型的文件大小，从而提高加载速度和减少带宽使用。\n\n```Javascript\nimport * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';\n\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\nconst dracoLoader = new DRACOLoader();\ndracoLoader.setDecoderPath('path/to/draco/gltf/'); // 设置 Draco 解码器路径\n\nconst loader = new GLTFLoader();\nloader.setDRACOLoader(dracoLoader);\n\nloader.load('path/to/your/model.gltf', (gltf) => {\n  scene.add(gltf.scene);\n  animate();\n}, undefined, (error) => {\n  console.error('An error happened', error);\n});\n\ncamera.position.z = 5;\n\nconst animate = () => {\n  requestAnimationFrame(animate);\n  renderer.render(scene, camera);\n};\n\n// 启动动画循环\nanimate();\n```\n\n#### 11.模型压缩原理\n\n- 为了减少模型的顶点和面数，同时使用法线贴图来保持视觉效果，可以使用 `gltf-pipeline` 和 `Draco` 压缩工具来优化 glTF 文件。\n\n```javascript\n1. 使用 gltf-pipeline 和 Draco 压缩工具优化 glTF 文件。\n  1. 减少体积\n  2. 减少计算量\n2. 在 Three.js 中加载和渲染优化后的 glTF 文件。\n3. 在模型上应用法线贴图。\n```\n\n#### 12.降低材质精度\n\n- 为了降低材质精度并尽量共享材质，可以在创建材质时设置材质的精度，并在多个网格之间共享同一个材质实例。\n\n```javascript\nimport * as THREE from 'three';\nimport { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';\n\nclass TextManager {\n  private scene: THREE.Scene;\n  private font: THREE.Font;\n  private sharedMaterial: THREE.MeshBasicMaterial;\n\n  constructor(scene: THREE.Scene, font: THREE.Font) {\n    this.scene = scene;\n    this.font = font;\n    this.sharedMaterial = new THREE.MeshBasicMaterial({\n      color: 0xffffff,\n      precision: 'lowp' // 设置材质精度为低精度\n    });\n  }\n\n  createText(data: { text: string, position: THREE.Vector3, rotate: number }) {\n    const geometry = new TextGeometry(data.text, {\n      font: this.font,\n      size: 20,\n      height: 2,\n    });\n\n    const mesh = new THREE.Mesh(geometry, this.sharedMaterial); // 使用共享材质\n\n    mesh.position.copy(data.position);\n    mesh.rotateY(data.rotate);\n\n    this.scene.add(mesh);\n  }\n}\n\n// 示例使用\nconst fontLoader = new THREE.FontLoader();\nfontLoader.load('path/to/font.json', (font) => {\n  const scene = new THREE.Scene();\n  const textManager = new TextManager(scene, font);\n\n  textManager.createText({ text: 'Hello, World!', position: new THREE.Vector3(0, 0, 0), rotate: 0 });\n  textManager.createText({ text: 'Another Text', position: new THREE.Vector3(1, 1, 1), rotate: Math.PI / 4 });\n\n  // 继续添加其他文本...\n});\n```\n\n#### 13.使用 LOD 技术优化\n\n- LOD（Level of Detail）技术是一种在 3D 图形中根据物体与相机的距离动态调整物体细节层次的技术。通过使用 LOD，可以在远距离时使用低细节模型，在近距离时使用高细节模型，从而提高渲染性能。\n- 利用压缩工具对同一种模型，导出 3 种精度的模型（顶点数量不一样）\n  1. 高精\n  2. 中等\n  3. low\n\n```javascript\nimport * as THREE from \"three\";\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader.js\";\nimport { DRACOLoader } from \"three/examples/jsm/loaders/DRACOLoader.js\";\n\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(\n  75,\n  window.innerWidth / window.innerHeight,\n  0.1,\n  1000\n);\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\nconst dracoLoader = new DRACOLoader();\ndracoLoader.setDecoderPath(\"path/to/draco/gltf/\"); // 设置 Draco 解码器路径\n\nconst loader = new GLTFLoader();\nloader.setDRACOLoader(dracoLoader);\n\nconst lod = new THREE.LOD();\n\nloader.load(\n  \"path/to/your/high-detail-model.gltf\",\n  (gltf) => {\n    const highDetailMesh = gltf.scene.children[0];\n    lod.addLevel(highDetailMesh, 0); // 0 表示在最近距离使用高细节模型\n  },\n  undefined,\n  (error) => {\n    console.error(\"An error happened\", error);\n  }\n);\n\nloader.load(\n  \"path/to/your/medium-detail-model.gltf\",\n  (gltf) => {\n    const mediumDetailMesh = gltf.scene.children[0];\n    lod.addLevel(mediumDetailMesh, 50); // 50 表示在中等距离使用中等细节模型\n  },\n  undefined,\n  (error) => {\n    console.error(\"An error happened\", error);\n  }\n);\n\nloader.load(\n  \"path/to/your/low-detail-model.gltf\",\n  (gltf) => {\n    const lowDetailMesh = gltf.scene.children[0];\n    lod.addLevel(lowDetailMesh, 100); // 100 表示在远距离使用低细节模型\n  },\n  undefined,\n  (error) => {\n    console.error(\"An error happened\", error);\n  }\n);\n\nscene.add(lod);\n\ncamera.position.z = 5;\n\nconst animate = () => {\n  requestAnimationFrame(animate);\n  lod.update(camera); // 更新 LOD\n  renderer.render(scene, camera);\n};\n\n// 启动动画循环\nanimate();\n```\n\n#### 14.使用 indexdb 存取模型\n\n- CDN 加速，强制缓存\n- 本地的加载模型，304 已经代表进行了协商缓存\n- 使用 indexdb 进行缓存\n\nIndexedDB 和 localStorage 都是浏览器提供的客户端存储解决方案，但它们在功能和使用场景上有显著的区别。\n\n```Javascript\nIndexedDB\n1. 数据存储类型：IndexedDB 是一个低级API，用于存储大量结构化数据（包括文件/二进制数据）。它支持事务、索引和键范围查询。\n2. 容量：IndexedDB 的存储容量通常比 localStorage 大得多，具体限制取决于浏览器和设备。\n3. 异步操作：IndexedDB 的操作是异步的，这意味着它不会阻塞主线程，适合处理大量数据。\n4. 数据类型：支持存储复杂的数据类型，包括对象、数组、文件等。\n5. 使用场景：适用于需要存储大量数据、复杂查询和事务处理的应用，如离线应用、PWA（渐进式Web应用）等。\n```\n\n```javascript\nlocalStorage\n1. 数据存储类型：localStorage 是一个简单的键值对存储，所有数据都以字符串形式存储。\n2. 容量：localStorage 的存储容量通常较小（约5MB），具体限制取决于浏览器。\n3. 同步操作：localStorage 的操作是同步的，这意味着它会阻塞主线程，不适合处理大量数据。\n4. 数据类型：只能存储字符串，需要手动序列化和反序列化复杂数据类型（如JSON）。\n5. 使用场景：适用于存储少量简单数据，如用户设置、会话信息等。\n```\n\n- Three.js 可以与 IndexedDB 一起使用来存储和检索 3D 模型。这可以提高应用的性能，特别是在需要频繁加载相同模型的情况下。\n\n```javascript\nimport * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nconst dbName = 'threejs-models';\nconst storeName = 'models';\n\nconst openDB = () => {\n  return new Promise<IDBDatabase>((resolve, reject) => {\n    const request = indexedDB.open(dbName, 1);\n\n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result;\n      db.createObjectStore(storeName, { keyPath: 'url' });\n    };\n\n    request.onsuccess = (event) => {\n      resolve((event.target as IDBOpenDBRequest).result);\n    };\n\n    request.onerror = (event) => {\n      reject((event.target as IDBOpenDBRequest).error);\n    };\n  });\n};\n\nconst storeModel = async (url: string, arrayBuffer: ArrayBuffer) => {\n  const db = await openDB();\n  const transaction = db.transaction(storeName, 'readwrite');\n  const store = transaction.objectStore(storeName);\n  store.put({ url, model: arrayBuffer });\n};\n\nconst loadModel = async (url: string) => {\n  const db = await openDB();\n  const transaction = db.transaction(storeName, 'readonly');\n  const store = transaction.objectStore(storeName);\n  return new Promise<ArrayBuffer | null>((resolve, reject) => {\n    const request = store.get(url);\n    request.onsuccess = () => {\n      resolve(request.result ? request.result.model : null);\n    };\n    request.onerror = () => {\n      reject(request.error);\n    };\n  });\n};\n\nconst loader = new GLTFLoader();\nconst modelUrl = 'path/to/your/model.gltf';\n\n// 加载模型并存储到 IndexedDB\nloader.load(modelUrl, async (gltf) => {\n  const arrayBuffer = await fetch(modelUrl).then(res => res.arrayBuffer());\n  await storeModel(modelUrl, arrayBuffer);\n  console.log('Model stored in IndexedDB');\n});\n\n// 从 IndexedDB 中加载模型\nloadModel(modelUrl).then((arrayBuffer) => {\n  if (arrayBuffer) {\n    const blob = new Blob([arrayBuffer], { type: 'model/gltf-binary' });\n    const url = URL.createObjectURL(blob);\n    loader.load(url, (gltf) => {\n      scene.add(gltf.scene);\n      console.log('Model loaded from IndexedDB');\n    });\n  } else {\n    console.log('Model not found in IndexedDB');\n  }\n});\n```\n\n#### 15.离屏渲染\n\n- 什么是离屏渲染\n\n  1.three 加载的模型一切皆对象，那么 three 经过一些列计算后，把模型渲染到屏幕上。那么离屏渲染就是不用渲染到屏幕上，因为渲染到屏幕（绘制）上一定会有一个过程叫 ➡ 光栅化\n\n光栅化的作用，就是将 3d 模型进行各种变化，通过 2d 渲染到屏幕上\n\n那么离屏 它就没有光栅化\n\n那么到底什么是离屏渲染呢、\n\n比如 b 页面是淘宝的双十一页面，那么进入双十一页面就必须先进入淘宝首页，那么我们可以在进入淘宝首页的时候就加载双十一页面，（只是加载，不渲染）这个就是离屏渲染。\n\n再比如：视频导出功能，浏览器可以录制 canvas 的渲染结果，浏览器有 api 可以把它录制下来，然后转成视频；我要录制一个 10s 的过程，大概是 600 帧，（1s60 帧，10s600 帧），这个时候就会从 canvas 截取 600 个画面，（600 个图），然后进行拼接成视频，剪映的导出就是离屏渲染。背后就是 canvas 在运行，输出画面。但是并没有进行绘制，因为绘制就涉及到了光栅化。还有一点就是导出时用户不需要看到画面。\n\n```javascript\nimport * as THREE from 'three';\nimport { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';\n\nclass TextManager {\n  private scene: THREE.Scene;\n  private font: THREE.Font;\n  private renderer: THREE.WebGLRenderer;\n  private renderTarget: THREE.WebGLRenderTarget;\n\n  constructor(scene: THREE.Scene, font: THREE.Font, renderer: THREE.WebGLRenderer) {\n    this.scene = scene;\n    this.font = font;\n    this.renderer = renderer;\n    this.renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);\n  }\n\n  createText(data: { text: string, position: THREE.Vector3, rotate: number }) {\n    const geometry = new TextGeometry(data.text, {\n      font: this.font,\n      size: 20,\n      height: 2,\n    });\n\n    const material = new THREE.ShaderMaterial({\n      vertexShader: `\n        void main() {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        void main() {\n          gl_FragColor = vec4(1.0,1.0,1.0,1.0);\n        }\n      `,\n    });\n\n    const mesh = new THREE.Mesh(geometry, material);\n    mesh.position.copy(data.position);\n    mesh.rotateY(data.rotate);\n\n    // 创建一个临时场景用于离屏渲染\n    const tempScene = new THREE.Scene();\n    tempScene.add(mesh);\n\n    // 使用 WebGLRenderTarget 进行离屏渲染\n    this.renderer.setRenderTarget(this.renderTarget);\n    this.renderer.render(tempScene, this.scene.children[0] as THREE.Camera);\n    this.renderer.setRenderTarget(null);\n\n    //切换页面了 将渲染结果添加到主场景中\n    this.scene.add(mesh);\n  }\n}\n```\n\n#### 16.场景阴影\n\n- 阴影在需要时打开\n\n```javascript\nif (data.castShadow) {\n  mesh.castShadow = true;\n}\nif (data.receiveShadow) {\n  mesh.receiveShadow = true;\n}\n```\n\n#### 17.降低渲染帧率\n\n- requestAnimationFrame 它可以获取到屏幕的刷新率，settimeout 不准确\n\n- 正常用户 80% 60 帧\n\n  根据用户设备性能，做判断。\n\n```Javascript\nconst start = () => {\n    controls.update();\n\n    city.start(clock.getDelta());\n    // 渲染场景\n    renderer.render(scene, camera)\n\n    requestAnimationFrame(start)\n  }\n\n  start();\n```\n\n#### 18.按需导入 Threejs 依赖，减少编译之后的包体积\n\n- Tree shaking 优化\n\n比如 1m 优化到 600k\n\n```javascript\nimport { WebGLRenderer, Scene, PerspectiveCamera, Color, Clock } from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls.js\";\nimport { City } from \"./City\"; // 假设 City 是你自定义的模块\n```\n\n#### 19.视锥体剔除\n\n- 视锥体剔除（Frustum Culling）是一种优化技术，用于在渲染场景时剔除那些不在相机视锥体内的物体，从而减少渲染负担。Three.js 内置了视锥体剔除功能，但你需要确保物体的 `frustumCulled` 属性设置为 `true`（默认值）。\n\n```Javascript\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { City } from './City'; // 假设 City 是你自定义的模块\n\n// 创建渲染器\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\n// 设置像素比\nrenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n// 设置场景颜色\nrenderer.setClearColor(new THREE.Color(0x000000), 1);\ndocument.body.appendChild(renderer.domElement);\n\n// 创建场景\nconst scene = new THREE.Scene();\n\n// 创建相机\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\ncamera.position.set(0, 1, 5);\n\n// 创建控制器\nconst controls = new OrbitControls(camera, renderer.domElement);\n\n// 实例化城市模型\nconst city = new City(scene, camera, controls);\nconst clock = new THREE.Clock();\n\n// 确保所有物体启用视锥体剔除\nscene.traverse((object) => {\n  if (object instanceof THREE.Mesh) {\n    object.frustumCulled = true;\n  }\n});\n\nconst start = () => {\n  controls.update();\n  city.start(clock.getDelta());\n  // 渲染场景\n  renderer.render(scene, camera);\n  requestAnimationFrame(start);\n};\n\nstart();\n\nwindow.addEventListener('resize', () => {\n  // 更新宽高比\n  camera.aspect = window.innerWidth / window.innerHeight;\n  // 更新相机的投影矩阵\n  camera.updateProjectionMatrix();\n  // 更新渲染器的尺寸\n  renderer.setSize(window.innerWidth, window.innerHeight);\n});\n```\n","categories":["Three.js"]},{"title":"Electron","url":"/posts/946.html","content":"\n# electron-跨平台桌面应用\n\n<!-- more -->\n\n### 1.认识 electron\n\n#### 1.什么是 Electron？\n\n```html\nElectron 是一个使用 JavaScript、HTML 和 CSS 构建桌面应用的框架。\n```\n\n#### 2.搭建项目\n\n- npm\n\n```shell\n$ npm create @quick-start/electron\n```\n\n- yarn\n\n```shell\n$ yarn create @quick-start/electron\n```\n\n- pnpm\n\n```shell\n$ pnpm create @quick-start/electron\n```\n\n​ 1.输入 electron，项目名称，按下回车第一步成功\n\n![img](https://z1.ax1x.com/2023/10/12/piSBG0s.png)\n\n​ 2.选择 react，按下回车第二步成功\n\n![img](https://z1.ax1x.com/2023/10/12/piSBJ7n.png)\n\n3.按一下 tab 键位，选择使用 ts，按下回车第三步成功\n\n![img](https://z1.ax1x.com/2023/10/12/piSBNt0.png)\n\n4.按一下 tab 键位，选择使用 plugin，按下回车第四步成功\n\n![img](https://z1.ax1x.com/2023/10/12/piSBdpT.png)\n\n5.按一下 tab 键位，选择开启 proxy，按下回车最后一步成功\n\n![img](https://z1.ax1x.com/2023/10/12/piSB0cF.png)\n","categories":["Electron"]},{"title":"Husky","url":"/posts/3045.html","content":"\n# Husky\n\n<!-- more -->\n\n#### 1.认识 Husky\n\n### 1.前提\n\n```yaml\n1.使用husky电脑必须安装git.\n2.在项目中使用husky必须要有git仓库,就是.git文件。如果没有,git init即可。\n```\n\n### 2. 集成 editorconfig 配置\n\nEditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。\n\n```yaml\n# http://editorconfig.org\n\nroot = true\n\n[*] # 表示所有文件适用\ncharset = utf-8 # 设置文件字符集为 utf-8\nindent_style = space # 缩进风格（tab | space）\nindent_size = 2 # 缩进大小\nend_of_line = lf # 控制换行类型(lf | cr | crlf)\ntrim_trailing_whitespace = true # 去除行尾的任意空白字符\ninsert_final_newline = true # 始终在文件末尾插入一个新行\n\n[*.md] # 表示仅 md 文件适用以下规则\nmax_line_length = off\ntrim_trailing_whitespace = false\n```\n\n- VSCode 需要安装一个插件：EditorConfig for VS Code\n\n![image-20210722215138665](https://z1.ax1x.com/2023/09/15/pPWtXSP.png)\n\n### 3. 使用 prettier 工具\n\nPrettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。\n\n1.安装 prettier\n\n```shell\nnpm install prettier -D\n```\n\n2.配置.prettierrc 文件：\n\n- useTabs：使用 tab 缩进还是空格缩进，选择 false；\n- tabWidth：tab 是空格的情况下，是几个空格，选择 2 个；\n- printWidth：当行字符的长度，推荐 80，也有人喜欢 100 或者 120；\n- singleQuote：使用单引号还是双引号，选择 true，使用单引号；\n- trailingComma：在多行输入的尾逗号是否添加，设置为 `none`，比如对象类型的最后一个属性后面是否加一个，；\n- semi：语句末尾是否要加分号，默认值 true，选择 false 表示不加；\n\n```json\n{\n  \"useTabs\": false,\n  \"tabWidth\": 2,\n  \"printWidth\": 80,\n  \"singleQuote\": true,\n  \"trailingComma\": \"none\",\n  \"semi\": false\n}\n```\n\n3.创建.prettierignore 忽略文件\n\n```\n/dist/*\n.local\n.output.js\n/node_modules/**\n\n**/*.svg\n**/*.sh\n\n/public/*\n```\n\n4.VSCode 需要安装 prettier 的插件\n\n5.测试 prettier 是否生效\n\n- 测试一：在代码中保存代码；\n- 测试二：配置一次性修改的命令；\n\n在 package.json 中配置一个 scripts：\n\n```json\n\"prettier\": \"prettier --write .\"\n```\n\n### 4. 使用 ESLint 检测\n\n1.在前面创建项目的时候，我们就选择了 ESLint，所以 Vue 会默认帮助我们配置需要的 ESLint 环境。\n\n2.VSCode 需要安装 ESLint 插件\n\n3.解决 eslint 和 prettier 冲突的问题：\n\n安装插件：（vue 在创建项目时，如果选择 prettier，那么这两个插件会自动安装）\n\n```shell\nnpm install eslint-plugin-prettier eslint-config-prettier -D\n```\n\n添加 prettier 插件：\n\n```json\n  extends: [\n    \"plugin:vue/vue3-essential\",\n    \"eslint:recommended\",\n    \"@vue/typescript/recommended\",\n    \"@vue/prettier\",\n    \"@vue/prettier/@typescript-eslint\",\n    'plugin:prettier/recommended'\n  ],\n```\n\n4.VSCode 中 eslint 的配置\n\n```json\n  \"eslint.lintTask.enable\": true,\n  \"eslint.alwaysShowStatus\": true,\n  \"eslint.validate\": [\n    \"javascript\",\n    \"javascriptreact\",\n    \"typescript\",\n    \"typescriptreact\"\n  ],\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": true\n  },\n```\n\n### 5.git Husky 和 eslint\n\n​ 1.虽然我们已经要求项目使用 eslint 了，但是不能保证组员提交代码之前都将 eslint 中的问题解决掉了，也就是我们希望保证代码仓库中的代码都是符合 eslint 规范的；\n\n​ 2.那么我们需要在组员执行 `git commit ` 命令的时候对其进行校验，如果不符合 eslint 规范，那么自动通过规范进行修复；\n\n那么如何做到这一点呢？可以通过 Husky 工具\n\n​ 3.husky 是一个 git hook 工具，可以帮助我们触发 git 提交的各个阶段：pre-commit、commit-msg、pre-push\n\n```shell\n安装: npx husky-init && npm install   有些电脑需要这样写 npx husky-init '&&' npm install\n```\n\n```shell\n1.安装husky相关的依赖:\n```\n\n![image-20210723112648927](https://z1.ax1x.com/2023/09/15/pPWD7GQ.png)\n\n```shell\n2.自动在项目目录下创建 `.husky` 文件夹:\n```\n\n![image-20210723112719634](https://z1.ax1x.com/2023/09/15/pPWrCRJ.png)\n\n```shell\n3.自动在package.json中添加一个脚本:\n```\n\n![image-20210723112817691](https://z1.ax1x.com/2023/09/15/pPWrFMR.png)\n\n```shell\n4.接下来，我们需要去完成一个操作：在进行git commit  -m ' ' 时，执行lint脚本:\n```\n\n![image-20210723112932943](https://z1.ax1x.com/2023/09/15/pPWrUJg.png)\n\n```shell\n5.出现这行即表示成功。在执行commit时，会自动执行npm run lint这行校验代码。帮助你去修复不规范的代码。\n```\n\n​ ![image-20210723112932943](https://z1.ax1x.com/2023/09/15/pPWsJXR.png)\n"},{"title":"Jquery","url":"/posts/14384.html","content":"\n# jQuery\n\n<!-- more -->\n\n#### 1.认识 jquery\n\n```javascript\njquery是一个快速，小型且功能丰富的javascript库。该库包含了dom操作，选择器，事件处理，动画和ajax等核心功能。\n现在我们可以简单的理解它就是一个js文件，执行该文件会给window对象添加一个jquery函数。(window.jquery) === $\n接着我们就可以调用jquery函数(工厂函数),或者使用该函数上的类方法。\n\n优点:跨浏览器支持:提供出色的跨浏览器支持(iE9+),无需编写额外代码\n\n缺点：jquery代码库一直在增长（自jquery1.5起超过200kb）\n不支持组件化开发\njquery更适合DOM操作，当涉及到开发复杂项目时，jquery能力有限。\n```\n\n#### 2.认识 CDN\n\nCDN 称之为成为内容分发网络。CDN 是网络系统给我们的资源增加访问速度，为源站减压。\n\n更简单的理解 CDN：\n\n​ CDN 会将资源缓存到遍布全球的网站，用户请求获取资源时，可就近获取 CDN 上的资源，提高资源访问速度，同时分担源站压力\n\n```javascript\n使用Jquery 方式一 cdn方式引入\n\n\nintegrity：hash资源,防止资源被篡改,如果浏览器发现资源被篡改,就不会加载该资源\ncrossorigin：加载不同源的资源时,浏览器是否需要携带用户凭证信息(eg:cookie,ssl证书)\n   anonymous：不需要携带\n   user-credentail 需要携带\n\n<script src=\"https://code.jquery.com/jquery-3.7.0.js\" integrity=\"sha256JlqSTELeR4TLqP0OG9dxM7yDPqX1ox/HfgiSLBj8+kM=\" crossorigin=\"anonymous\"></script>\n\n\n正常使用： <script src=\"https://code.jquery.com/jquery-3.7.0.js\"></script>\n```\n"},{"title":"Sequelize","url":"/posts/35110.html","content":"\n# 你真正了解 sequelize 吗\n\n<!-- more -->\n\n### 主键\n\n```\n{ primaryKey: true }\n```\n\n### 唯一键\n\n```\n{ unique: true }\n{ unique: 'compositeIndex' }\n```\n\n### 自增\n\n```\n{ autoIncrement: true }\n```\n\n### 允许为空\n\n```\n{ allowNull: true }\n```\n\n### 默认值\n\n```\n{ defaultValue: true }\n{ defaultValue: DataTypes.NOW }\n```\n\n### 属性/外键\n\n```\npersonId: {\n  type: Sequelize.INTEGER,\n  references: 'persons',\n  referencesKey: 'id'\n}\n```\n\n##### 安装\n\n```\nnpm install --save sequelize\n$ npm install --save mysql2\n```\n\n###### 测试连接\n\n```\nsequelize\n    .authenticate()\n    .then(() => {\n        console.log('Connection has been established successfully.');\n    })\n    .catch(err => {\n        console.error('Unable to connect to the database:', err);\n    });\n// 测试完注释掉即可\n```\n\n###### 使用 sequelize\n\n```\nconst sequelize = new Sequelize('db','root','123456',{\n  dialect:'mysql',\n  host:'127.0.0.1',\n  timezone:'+08:00', //这里是东八区,默认为0时区\n  //连接池 最大5个 最小0个 时间10000毫秒\n  pool:{\n    max:5,\n    min:0,\n    acquire:30000,\n    idle:10000,\n  }\n})\n```\n\n###### 创建数据库表(创建模型 就是字段)\n\n```\nconst book = sequelize.define('book',{\n   name:{\n    type:DataTypes.STRING,\n    allowNull:false,\n   },\n   price:{\n    type:DataTypes.INTEGER,\n   },\n   author:DataTypes.STRING,\n   type:DataTypes.STRING,\n},{\n  //关闭默认创建字段的开始时间和结束时间\n  timestamps:false,\n})\n// 更多的查看官网\nhttps://www.sequelize.cn/core-concepts/model-basics\n```\n\n###### 插入数据\n\n```\nasync function inits(){\n//将创建表,如果表已经存在,则将其首先删除(用户模型表刚刚(重新)创建)  sequelize实例同步所有模型字段\n  await sequelize.sync({\n    force:true\n  })\n  //插入多条数据  单条数据create({name:'张三',price:20})\n  await book.bulkCreate(\n   [\n    {\n      name: 'Rick And Morty - The first season',\n      price: 30,\n      author: 'unkwon',\n      type: 'comic'\n    },\n    {\n      name: 'Rick And Morty',\n      price: 300,\n      author: 'unkwon',\n      type: 'comic'\n    },\n    {\n      name: 'Rick And',\n      price: 3000,\n      author: 'unkwon',\n      type: 'comic'\n    },\n   ]\n  )\n}\n\ninits();\n```\n\n```express\n// 每次连接都将把原来的表删除,然后做一次同步\nsequelize.sync({\n   force:true,\n }).then(()=> user.create({\n     firstName:'四哥',\n     lastName:'aosika'\n }).then(()=>{\n   return user.findAll({\n     where:{\n       firstName:'四哥'\n      }\n    })\n  }).then(console.log)\n)\n```\n\n### express res.send()和 res.json()的区别\n\n```\nres.json()的返回结果\nResponse Headers 响应头中\n  content-Type:application/json;charset=utf-8;\n\nres.send()\nResponse Headers\n  content-Type:text/html;charset=utf-8;\n```\n\n###### 为什么使用数据库连接池\n\n```\n数据库连接是一种关键、有限且昂贵的资源，创建和释放数据库连接是一个很耗时的操作，频繁地进行这样的操作将占用大量的性能开销，进而导致网站的响应速度下降，严重的时候可能导致服务器崩溃；数据库连接池可以节省系统许多开销。\n\n它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个；释放空闲时间超过最大空闲时间的数据库连接以避免因为没有释放数据库连接而引起的数据库连接遗漏。\nhttps://blog.csdn.net/weixin_42867975/article/details/90306610\n\nhttps://www.cnblogs.com/xsilence/p/12444228.html#:~:text=%E8%AF%AD%E6%B3%95%20%EF%BC%881%EF%BC%89createConnection%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5%E5%AF%B9%E8%B1%A1%EF%BC%88%E6%AD%A3%E5%BC%8F%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%9A%E4%BD%BF%E7%94%A8createConnection%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%A4%BA%E4%B8%8Emysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9E%E6%8E%A5%E7%9A%84connection%E5%AF%B9%E8%B1%A1%EF%BC%89%20var%20connection%20%3D%20mysql.%20createConnection%20%28options%29%3B,%EF%BC%882%EF%BC%89%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84connect%E6%96%B9%E6%B3%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E3%80%82%20connection.%20connect%20%28function%20%28err%29%20%7B%20%2A%2A%2A%20%7D%29%3B\n```\n\n###### 在设计数据库时为什么有的时候需要使用外键\n\n```\n什么是外键：\n外键 (FK) 是用于建立和加强两个表数据之间的链接的一列或多列。通过将保存表中主键值的一列或多列添加到另一个表中，可创建两个表之间的链接。这个列就成为第二个表的外键。\n   外键可以保证数据的参照完整性。\n如果一个健壮的系统，数据库中的数据一定有很好的参照完整性，如果不用外键，就要多写代码对数据的完整性进行额外的判断\n\t用程序(代码)控制，有很多缺点；录入成绩单时为了保证学号有效，首先要搜索档案，当档案很大时会影响效率。程序控制并不能保证百分之百引用完整性，尤其是并发操作。\n\t说一个特例（主要是说明程序控制不好）：\nA录入成绩单，B在编辑档案。\n当A录入张三的成绩，保存时，搜索张三存在，于是程序下一步就要存盘，但这时B恰好把张三删除了。但A那边的程序并不知道，于是就把一条垃圾数据存进数据库中了。\n此例的操作流程正确与否不重要，但说明了程序控制并不是好方法。\n```\n\n###### express 中的 req.params,req.query,req.body;\n\n```\nreq.params 是获取路由的url路径参数\nhttp:localhost:3000/test/1\nreq.query 是获取路由的查询参数\nhttp:localhost:3000/test?id=1;\n以上两种一般用于get请求;(params和query与前端作用相同)\nreq.body 一般用于post请求\nreq.body是用来解析post请求中的数据,前端数据发送给后端的时候,用req.body用来接收。\n```\n\n```express\nrouter.post('/login',function(req,res){\n    let username=req.body.username;\n    let password=req.body.password;\n    if(username && password){\n        res.send({\n            code:200,\n            username:username,          token:'dhuadh123hui213h,dqwdfiuejnfuiwjf,fewkio0kjfi9203kjirjf'\n        })\n    }else{\n        code:500,\n        res.send({\n            msg:'用户名密码错误'\n        })\n    }\n})\n```\n\n###### 为什么分类页面接口写 2 个响应速度最快\n\n```\n因为分类页面分为左右两部分，分为2个接口一方面是数据少响应快，第二是因为如果加了redis就更快了\n```\n\n###### 为什么首页使用 redis 后每次请求数据的时间还变慢了\n\n```\n因为使用redis后第一次请求的时候是从数据库开始请求数据的，数据很多，响应的快，第二次请求的时候redis已经将数据保存在缓存中了，将大量数据都保存在缓存中，就好比一个池子一样，找到对应的一条数据响应时间边长，但是这样的好处不仅减少了数据库的压力，更大的减少了资源的浪费\n```\n\n###### token\n\n```\ntokend是一个令牌，用来验证哪一个用户的\n作用：验证用户 比如张三 李四\ntoken是后端生成的,并且token是不能重复的\nnpm install --save jsonwebtoken\n```\n"},{"title":"Mysql","url":"/posts/62688.html","content":"\n# Mysql\n\n<!-- more -->\n\n```mysql\n关系型数据库和非关系型数据库\n  关系型数据库指的是使用关系模型（二维表格模型）来组织数据的数据库。\n  非关系型数据库又被称为 NoSQL（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定，常用于存储非结构化的数据。\n```\n\n```\nMysql -u root -p\n123456\n```\n\n```\nshow databases;\n```\n\n```\nuse db;\nselect database(); 查看使用的哪个数据库\n```\n\n```\n创建数据库\ncreate database if not exists douyu;\ncreate database if not exists huya default character set utf8mb4;\n```\n\n```\ndrop database if exists huya;\n```\n\n```\n查看所有的表 show tables;\n查看表的结构 desc students;\n创建表\ncreate table if not exists `students`(\n\t`name` varchar(10),\n\t`age` int,\n\t`score` int\n);\n删除表 drop table if exists `students`;\n```\n\n```\n完整表  查看字段 右击->设计表\ncreate table if not exists `users`(\n\tid int primary key auto_increment,//主键 自动增长\n\tname varchar(20) not null,\n\tage int default 0,\n\tphoneNum varchar(20) unique not null,//unique唯一的\n\tcreatetime timestamp //时间戳\n)\n修改表的名字 alter table `users` rename to `user`;\n添加一个新的列 alter table `user` add `updatetime` timestamp\n修改字段的名字 alter table `user` change `phoneNum` `elephone` varchar(20)\n修改字段的类型 alter table `user` modify `name` varchar(30)\n删除某一个字段 alter table `user` drop age;\n```\n\n```\n插入数据 Affcted row:1 表示成功 且插入的数据不能重复，否则会报1062\ninsert into `user` values(0,'zzz','080-110110','2020-10-10','2020-12-10');\ninsert into `user` (name,elephone,createtime,updatetime)\n\tvalues ('acd','789-201030','1999-10-1','2000-1-9');\n删除符合条件的数据 delete from `user` where id = '116';\n更新符合条件的数据 update `user` set name='lougou',elephone='321-333333' where id = '117';\n```\n\n```\n数据的查询语句\n# 创建products的表\nCREATE TABLE IF NOT EXISTS `products` (\n\tid INT PRIMARY KEY AUTO_INCREMENT,\n\tbrand VARCHAR(20),\n\ttitle VARCHAR(100) NOT NULL,\n\tprice DOUBLE NOT NULL, //双精度浮点型    16位精度(8字节)\n\tscore DECIMAL(2,1), //精准数据类型\n\tvoteCnt INT,\n\turl VARCHAR(100),\n\tpid INT\n);\n//根据js代码把数据插入数据库\n\n```\n","categories":["Mysql"]}]